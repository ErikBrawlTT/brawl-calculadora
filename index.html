<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Calculadora Brawl Stars</title>
<link href="https://fonts.googleapis.com/css2?family=Bangers&family=Orbitron:wght@700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
<style>
/* ==== CSS BASE ==== */
body { margin: 0; font-family: 'Bangers', cursive; background: url('Personajes-Brawl-Stars.webp') no-repeat center center fixed; background-size: cover; color: white; text-align: center; position: relative; }
body::after { content: ""; position: fixed; inset: 0; background: rgba(0,0,0,0.6); backdrop-filter: blur(6px); z-index: 0; }
.container { position: relative; z-index: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; padding: 20px; }
h1 { font-size: 3rem; margin-bottom: 20px; display: flex; align-items: center; justify-content: center; gap: 10px; font-family: 'Bangers', cursive; color: #FFD700; text-shadow: -2px -2px 0 black, 2px -2px 0 black, -2px 2px 0 black, 2px 2px 0 black; }
h1 .diamond { font-family: 'Bangers', cursive; font-size: 3rem; color: #32CD32; text-shadow: -1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000,0 0 6px #32CD32,0 0 12px #00FF00,0 0 18px #00FF7F; animation: glow 1.5s infinite alternate; }
@keyframes glow { 0% { text-shadow: -1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000,0 0 4px #32CD32,0 0 8px #00FF00,0 0 12px #00FF7F; } 50% { text-shadow: -1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000,0 0 8px #32CD32,0 0 16px #00FF00,0 0 24px #00FF7F; } 100% { text-shadow: -1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000,0 0 4px #32CD32,0 0 8px #00FF00,0 0 12px #00FF7F; } }
form { background: rgba(0,0,0,0.5); border-radius: 60px; padding: 20px; max-width: 600px; width: 90%; margin-bottom: 15px; display: flex; flex-direction: column; align-items: center; position: relative; border: 2px solid #FFA500; box-shadow: 0 0 18px rgba(255,165,0,.7),0 0 36px rgba(255,165,0,.35); }
label { display:flex; justify-content:space-between; margin:8px 0; width:100%; }
input { width:100px; text-align:center; border:none; border-radius:8px; }
.buttons { display:flex; justify-content:center; gap:25px; margin-top:15px; }
button { padding:10px 20px; border:none; border-radius:12px; font-family:'Bangers'; font-size:1.5rem; color:white; cursor:pointer; transition: transform .08s ease; }
button:active { transform: scale(0.97); }
button.flash { box-shadow: 0 0 20px #fff,0 0 30px #fff,0 0 40px #fff; transition: box-shadow 0.2s ease; }
#calcBtn,#clearBtn{background: linear-gradient(90deg,#FFD700,#FFA500); color: black;}
#shareBtn{ background:linear-gradient(90deg,#00FFAA,#FF00FF); margin-top:20px; color:white; }
#shareBtn.pulse { animation: pulseBorder 1s infinite; }
@keyframes pulseBorder { 0% { box-shadow: 0 0 10px #FF00FF,0 0 20px #FF00FF; transform: scale(1); } 50% { box-shadow: 0 0 25px #FF00FF,0 0 35px #FF00FF; transform: scale(1.05); } 100% { box-shadow: 0 0 10px #FF00FF,0 0 20px #FF00FF; transform: scale(1); } }
#spinBtn{ margin-top:10px; padding:8px 16px; font-size:1.1rem; background: linear-gradient(90deg,#FFA500,#FF8C00); color:#000; box-shadow: 0 0 10px #FFA500,0 0 20px rgba(255,165,0,.5); border-radius: 12px; }
#infoBtn{ position:absolute; top:50%; left:50%; transform: translate(-50%, -50%); width:70px; height:70px; border-radius:50%; background: rgba(20,0,30,.25); border: 2px solid #B300FF; display:flex; align-items:center; justify-content:center; letter-spacing: 2px; color: #FFFFFF; font-size: 1.1rem; text-shadow: 0 0 6px #B300FF,0 0 12px #8000FF; box-shadow: 0 0 10px #B300FF,0 0 20px rgba(179,0,255,.35); cursor:pointer; z-index:2; animation: infoPulse 1.6s ease-in-out infinite; }
@keyframes infoPulse{ 0% { box-shadow:0 0 8px #B300FF,0 0 16px rgba(179,0,255,.25); } 50% { box-shadow:0 0 14px #B300FF,0 0 28px rgba(179,0,255,.45); } 100% { box-shadow:0 0 8px #B300FF,0 0 16px rgba(179,0,255,.25); } }
.metric-container { display: flex; justify-content: center; gap: 22px; margin-top: 18px; }
.metric { display: flex; flex-direction: column; align-items: center; gap: 6px; font-family:'Orbitron', sans-serif; font-size: 2rem; }
.metric .box { background: rgba(0,0,0,0.7); padding: 8px 18px; border-radius: 12px; min-width: 70px; text-align: center; font-weight: 700; user-select: none; transition: all 0.2s ease; cursor:pointer; }
.metric.visitas .box { border: 2px solid #00CFFF; color: #00CFFF; box-shadow:0 0 10px #00CFFF,0 0 20px #00CFFF;}
.metric.likes .box { border: 2px solid #39ff14; color: #39ff14; box-shadow:0 0 10px #39ff14,0 0 20px #39ff14;}
.metric.dislikes .box { border: 2px solid #FF073A; color: #FF073A; box-shadow:0 0 10px #FF073A,0 0 20px #FF073A;}
canvas{ margin-top:15px; max-width:400px; position:relative; }
#centerDiamond { position: absolute; top: 43%; left: 50%; transform: translate(-50%, -50%); display: block; }
#centerDiamond img { width: 210px; height: 210px; border-radius: 50%; object-fit: contain; background: rgba(0,0,0,0.3); transition: all 0.4s ease; }
#centerDiamond img.finalGlow { box-shadow: 0 0 20px #fff, 0 0 40px #fff, 0 0 60px #fff; }
#resultado { margin:10px 0; font-size:2rem; font-family:'Bangers'; color:#00FF00; text-shadow:0 0 8px #00FF00,0 0 15px #00FF00; }
#infoModal{ position: fixed; inset: 0; background: rgba(0,0,0,.8); display:none; align-items:center; justify-content:center; z-index: 9999; }
#infoModal .content{ background: #0f0b18; border: 2px solid #FFD700; box-shadow: 0 0 18px #FFD700,0 0 36px rgba(255,215,0,.4); border-radius: 16px; max-width: 560px; width: 90%; padding: 18px 18px 12px; text-align: left; font-family: 'Orbitron', sans-serif; color: #fff; }
#infoModal .content h3{ margin: 0 0 8px; color: #FFD700; font-family: 'Bangers'; font-size: 1.8rem; }
#infoModal .content p{ margin: 6px 0; line-height: 1.35; font-size: 1rem; }
#infoClose{ float:right; font-size: 1.5rem; color: #FF4D4D; cursor:pointer; margin-left: 8px; }
#infoClose:hover{ filter: brightness(1.2); }
.segmentGlowBlue { box-shadow:0 0 15px 4px #00CFFF; }
.segmentGlowRed { box-shadow:0 0 15px 4px #FF073A; }
.segmentGlowOrange { box-shadow:0 0 15px 4px #FFA500; }
.segmentGlowGreen { box-shadow:0 0 15px 4px #00FF00; }
.glow-blue { box-shadow: 0 0 25px #00f, 0 0 50px #00f, 0 0 75px #00f, 0 0 100px #00CFFF; animation: glow-blue 3s infinite alternate; }
.glow-red  { box-shadow: 0 0 20px #f00, 0 0 40px #f00, 0 0 60px #f00; animation: glow-red 3s infinite alternate; }
.glow-orange { box-shadow: 0 0 20px #f90, 0 0 40px #f90, 0 0 60px #f90; animation: glow-orange 3s infinite alternate; }
.glow-green { box-shadow: 0 0 20px #0f0, 0 0 40px #0f0, 0 0 60px #0f0; animation: glow-green 3s infinite alternate; }
@keyframes glow-blue { 0% { box-shadow: 0 0 10px #00f, 0 0 20px #00CFFF; } 50% { box-shadow: 0 0 40px #00f, 0 0 80px #00CFFF; } 100% { box-shadow: 0 0 10px #00f, 0 0 20px #00CFFF; } }
@keyframes glow-red { 0% { box-shadow: 0 0 10px #f00, 0 0 20px #f00; } 50% { box-shadow: 0 0 25px #f00, 0 0 45px #f00; } 100% { box-shadow: 0 0 10px #f00, 0 0 20px #f00; } }
@keyframes glow-orange { 0% { box-shadow: 0 0 10px #f90, 0 0 20px #f90; } 50% { box-shadow: 0 0 25px #f90, 0 0 45px #f90; } 100% { box-shadow: 0 0 10px #f90, 0 0 20px #f90; } }
@keyframes glow-green { 0% { box-shadow: 0 0 10px #0f0, 0 0 20px #0f0; } 50% { box-shadow: 0 0 25px #0f0, 0 0 45px #0f0; } 100% { box-shadow: 0 0 10px #0f0, 0 0 20px #0f0; } }
</style>
</head>
<body>
<div class="container">
  <h1><span class="diamond">‚≠ê</span> Calculadora Brawl Stars <span class="diamond">‚≠ê</span></h1>
  <form id="calcForm">
    <label>üéüÔ∏è Brawl Pass: <input type="number" id="bpass" value="0"></label>
    <label>ü©µ Comunes: <input type="number" id="comunes" value="0"></label>
    <label>üíö Raras: <input type="number" id="raras" value="0"></label>
    <label>üíú √âpicas: <input type="number" id="epicas" value="0"></label>
    <label>‚ù§Ô∏è M√≠ticas: <input type="number" id="miticas" value="0"></label>
    <label>üåü Legendarias: <input type="number" id="legendarias" value="0"></label>
    <label>‚ö° Hipercarga: <input type="number" id="hipercarga" value="0"></label>
    <label>üî• Maxeados: <input type="number" id="maxeados" value="0"></label>
    <button type="button" id="infoBtn">INFO</button>
  </form>
  <div id="resultado">Valor total: 0 ü™ô</div>
  <div class="buttons">
    <button id="calcBtn">Calcular</button>
    <button id="clearBtn">Limpiar</button>
  </div>
  <button id="shareBtn">üì§ Compartir</button>
  <button id="spinBtn">üé≤ Girar Brawler</button>
  <div class="metric-container">
    <div class="metric visitas"><span class="icon">üëÄ</span><div class="box" id="visitas-counter">0</div></div>
    <div class="metric likes"><span class="icon">üëç</span><div class="box" id="likes-counter">0</div></div>
    <div class="metric dislikes"><span class="icon">üëé</span><div class="box" id="dislikes-counter">0</div></div>
  </div>
  <div style="position:relative; display:inline-block;">
    <canvas id="myChart" width="400" height="400"></canvas>
    <div id="centerDiamond">
      <img id="brawlerImg" src="" alt="Brawler">
    </div>
  </div>
  <div id="infoModal">
    <div class="content">
      <span id="infoClose">√ó</span>
      <h3>Informaci√≥n</h3>
      <p>Hola BRAWLER, esta es la calculadora que siempre has so√±ado probar.</p>
      <p>- üéüÔ∏è Brawl Pass: Ingresa el total aprox. de los BrawlPass que has utilizado.</p>
      <p>- ü©µüíöüíú‚ù§Ô∏èüåü Skins: Ingresa la cantidad de skins ( en la tienda del juego, cada modalidad tiene su total en la parte superior derecha‚ÜóÔ∏è ).</p>
      <p>- ‚ö°üî• Brawlers maxeados: Sumando los Brawlers maxeados con sus hipercargas, sabr√°s el valor aproximado de tu cuenta.</p>
      <p>- üé≤ Interactua: ¬°Gira y juega! Este es tu Brawler del dia,aparecera dentro de un glowüü¢! vuelve ma√±ana sera otroüéØ.</p>
      <p>¬°A qu√© esperas! Haz tu c√°lculo, deja tu likeüëç comparteüì§ vuelve al juego y dale ca√±aüèÜ.</p>
    </div>
  </div>
    <script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

document.addEventListener('DOMContentLoaded', () => {
  const supabase = createClient(
    'https://ttkneykkrkbajymzsgcr.supabase.co',
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR0a25leWtrcmtiYWp5bXpzZ2NyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU5OTAyMjIsImV4cCI6MjA3MTU2NjIyMn0.Zsqy_PZ6K-3iTjh7nkTyH-7M9gOnSFHt4f0p9y_WPiE'
  );
  const PAGE_ID = 'pagina1';

  /* ===== ELEMENTOS ===== */
  const calcBtn = document.getElementById('calcBtn');
  const clearBtn = document.getElementById('clearBtn');
  const shareBtn = document.getElementById('shareBtn');
  const spinBtn = document.getElementById('spinBtn');
  const infoBtn = document.getElementById('infoBtn');
  const infoModal = document.getElementById('infoModal');
  const infoClose = document.getElementById('infoClose');
  const brawlerImg = document.getElementById('brawlerImg');

  const visitasCounter = document.getElementById('visitas-counter');
  const likesCounter = document.getElementById('likes-counter');
  const dislikesCounter = document.getElementById('dislikes-counter');

  /* ===== UTILIDADES ===== */
  function beep(freq){
    const ctx = new (AudioContext||webkitAudioContext)(),
          o = ctx.createOscillator(),
          g = ctx.createGain();
    o.type="square"; o.frequency.value=freq; o.connect(g); g.connect(ctx.destination);
    g.gain.setValueAtTime(.15,ctx.currentTime); o.start(); o.stop(ctx.currentTime+.15);
  }
  function vibrar(ms=80){ if(navigator.vibrate) navigator.vibrate(ms); }

  /* ===== CONTADORES METRICAS ===== */
  async function cargarMetricas(){
    const { data, error } = await supabase.from('metrics').select('visitas,likes,dislikes').eq('page_id', PAGE_ID).single();
    if (!error && data){
      animateCounter('visitas-counter', data.visitas);
      animateCounter('likes-counter', data.likes);
      animateCounter('dislikes-counter', data.dislikes);
    }
  }
  async function incrementarVisita(){
    try{
      await supabase.rpc('increment_visitas',{pid: PAGE_ID});
      await cargarMetricas();
    }catch(e){ console.error(e); }
  }
  function animateCounter(id, value){
    const el = document.getElementById(id);
    let start = parseInt(el.innerText)||0;
    const end = Number(value)||0;
    const duration = 800;
    const t0 = performance.now();
    function step(t){
      const p = Math.min((t-t0)/duration,1);
      el.innerText = Math.floor(start + (end-start)*p);
      if(p<1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  /* ===== BOTONES ===== */
  calcBtn.addEventListener('click', () => { 
    beep(520); vibrar(80); 
    calcular(); 
    document.getElementById('myChart').scrollIntoView({behavior:'smooth', block:'end'}); 
  });
  clearBtn.addEventListener('click', () => { 
    limpiar(); 
    document.getElementById('calcForm').scrollIntoView({behavior:'smooth', block:'start'}); 
  });
  shareBtn.addEventListener('click', share);
  spinBtn.addEventListener('click', () => { 
    beep(520); vibrar(80); 
    // si el bot√≥n est√° habilitado, lanza la ruleta
    if(!spinBtn.disabled) spinRouletteSmooth(); 
    document.getElementById('myChart').scrollIntoView({behavior:'smooth', block:'end'}); 
  });
  infoBtn.addEventListener('click', ()=> infoModal.style.display='flex');
  infoClose.addEventListener('click', ()=> infoModal.style.display='none');
  infoModal.addEventListener('click', e=> { if(e.target===infoModal) infoModal.style.display='none'; });
  shareBtn.classList.add('pulse');

  /* ===== BRAWLERS ===== */
  const allBrawlers = ["elprimo","colt","nita","edgar","spike","penny","darryl","rico","mortis","bea","8-bit","alli","amber","angelo","ash","barley","belle","berry","bibi","bo","bonnie","brock","bull","buster","buzz","byron","carl","charly","chester","chuck","clancy","colette","cordelius","crow","doug","draco","dynamike","eve","fang","finx","frank","gale","genio","gray","griff","grom","hank","gus","jacky","jae-yong","janet","jessie","max","meeple","meg","melodie","mico","moe","nani","otis","ollie","pam","pearl","piper","poco","r-t","rosa","ruffs","sam","sandy","shade","shelly","sprout","squeak","stu","surge","tick","trunk","willow"];
  const baseURL = "https://raw.githubusercontent.com/ErikBrawlTT/brawl-calculadora/main/Brawlers/";
  let chart;

  /* --- Nota: mantengo tu brawlerCache original (con todas las im√°genes) para no quitar nada del script --- */
  const brawlerCache = {};
  allBrawlers.forEach(name => { 
    const img = new Image(); 
    img.src = baseURL+name+".png"; 
    brawlerCache[name]=img; 
  });

  /* ===== NUEVO: seleccionamos 20 brawlers aleatorios "activos" y esperamos a que carguen (si pueden) ===== */
  let activeBrawlers = []; // nombres de los 20 escogidos (los que usar√° la ruleta)
  let activePrepared = false;

  function pickRandomUnique(arr, count){
    const copy = [...arr];
    for(let i = copy.length - 1; i > 0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy.slice(0, Math.min(count, copy.length));
  }

  function prepareActiveBrawlers(count = 20, timeoutMs = 8000){
    // Devuelve una promesa que resuelve cuando la selecci√≥n/precarga ha terminado (o ha pasado timeout)
    return new Promise(resolve => {
      const selected = pickRandomUnique(allBrawlers, count);
      activeBrawlers = selected.slice(); // inicializa la lista activa
      // Si ya existen Image() en brawlerCache para esos nombres, esperamos a que se hayan cargado
      const promises = activeBrawlers.map(name => {
        return new Promise(res => {
          const img = brawlerCache[name];
          if(!img){
            // si por alguna raz√≥n no existe en cache, crea uno y espera carga
            const newImg = new Image();
            newImg.src = baseURL + name + ".png";
            brawlerCache[name] = newImg;
            newImg.onload = () => res({name, ok:true});
            newImg.onerror = () => res({name, ok:false});
          } else {
            if(img.complete && img.naturalWidth>0) return res({name, ok:true});
            // si no est√° completa, agregamos handlers
            const t = setTimeout(()=> res({name, ok: false}), timeoutMs); // timeout por seguridad
            img.onload = () => { clearTimeout(t); res({name, ok:true}); };
            img.onerror = () => { clearTimeout(t); res({name, ok:false}); };
          }
        });
      });

      Promise.all(promises).then(results => {
        // Filtramos los que realmente cargaron correctamente
        const ok = results.filter(r => r.ok).map(r => r.name);
        if(ok.length > 0){
          activeBrawlers = ok; // usamos solo los que cargaron
        } else {
          // si nada carg√≥, como fallback, usamos el subset de allBrawlers que s√≠ esten cargadas en brawlerCache
          const loadedAny = Object.keys(brawlerCache).filter(n => {
            const im = brawlerCache[n];
            return im && im.complete && im.naturalWidth>0;
          });
          if(loadedAny.length>0) activeBrawlers = pickRandomUnique(loadedAny, Math.min(count, loadedAny.length));
          else activeBrawlers = pickRandomUnique(allBrawlers, Math.min(count, allBrawlers.length)); // √∫ltimo recurso
        }

        activePrepared = true;
        // Habilitar bot√≥n spin
        if(spinBtn) spinBtn.disabled = false;
        resolve(activeBrawlers);
      });
    });
  }

  /* ===== FUNCIONES DE IMAGEN SEGURO (fallback si falla) ===== */
  function getLoadedImagesFromList(list){
    return list
      .map(name => brawlerCache[name])
      .filter(img => img && img.complete && img.naturalWidth>0);
  }

  function safeSetBrawler(name, fallbackClass="finalGlow"){
    // intenta pintar name; si no est√° disponible, elige otra ya cargada de activeBrawlers; si tampoco, de todo brawlerCache; si no, placeholder
    const img = brawlerCache[name];
    const loadedActive = getLoadedImagesFromList(activeBrawlers);
    const loadedAny = Object.values(brawlerCache).filter(i=>i && i.complete && i.naturalWidth>0);
    if(img && img.complete && img.naturalWidth>0){
      brawlerImg.src = img.src;
    } else if(loadedActive.length > 0){
      const choice = loadedActive[Math.floor(Math.random()*loadedActive.length)];
      brawlerImg.src = choice.src;
    } else if(loadedAny.length > 0){
      const choice = loadedAny[Math.floor(Math.random()*loadedAny.length)];
      brawlerImg.src = choice.src;
    } else {
      // √∫ltimo recurso: placeholder
      brawlerImg.src = "https://via.placeholder.com/210x210?text=Brawler";
    }
    brawlerImg.className = fallbackClass;
  }

  /* ===== CALCULAR ===== */
  function calcular(){
    beep(600); vibrar();
    calcBtn.classList.add('flash'); setTimeout(()=>calcBtn.classList.remove('flash'),200);

    const bpass = Number(document.getElementById("bpass").value)||0;
    const comunes = Number(document.getElementById("comunes").value)||0;
    const raras = Number(document.getElementById("raras").value)||0;
    const epicas = Number(document.getElementById("epicas").value)||0;
    const miticas = Number(document.getElementById("miticas").value)||0;
    const legendarias = Number(document.getElementById("legendarias").value)||0;
    const hipercarga = Number(document.getElementById("hipercarga").value)||0;
    const maxeados = Number(document.getElementById("maxeados").value)||0;

    const valores={
      "üéüÔ∏è Brawl Pass":bpass*10,
      "ü©µ Comunes":comunes*2,
      "üíö Raras":raras*5,
      "üíú √âpicas":epicas*10,
      "‚ù§Ô∏è M√≠ticas":miticas*12,
      "üåü Legendarias":legendarias*15,
      "‚ö° Hipercarga":hipercarga*20,
      "üî• Maxeados":maxeados*50
    };
    const total = Object.values(valores).reduce((a,b)=>a+b,0);

    const resultadoEl = document.getElementById("resultado");
    let start = parseInt(resultadoEl.innerText.replace(/\D/g,''))||0;
    const end = total;
    const duration = 800;
    const t0 = performance.now();
    function step(t){
      const p = Math.min((t-t0)/duration,1);
      resultadoEl.innerText = "Valor total: "+Math.floor(start + (end-start)*p)+" ü™ô";
      if(p<1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);

    const data={labels:Object.keys(valores),datasets:[{data:Object.values(valores),backgroundColor:["#00FFFF","#00FF00","#FF00FF","#FFFF00","#FF4500","#00CFFF","#FF69B4","#FF0000"],borderWidth:2}]};
    const config={type:'doughnut',data:data,options:{cutout:"70%",plugins:{legend:{display:true,position:'bottom'}}}};
    if(chart) chart.destroy();
    chart = new Chart(document.getElementById('myChart').getContext('2d'), config);

    confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
    document.getElementById('centerDiamond').style.display="block";
  }

  /* ===== LIMPIAR ===== */
  function limpiar(){
    beep(300); 
    vibrar();
    clearBtn.classList.add('flash'); 
    setTimeout(()=>clearBtn.classList.remove('flash'),200);

    // Reset formulario y resultado
    document.getElementById("calcForm").reset();
    document.getElementById("resultado").innerText="Valor total: 0 ü™ô";

    // Destruir gr√°fico si exist√≠a
    if(chart) chart.destroy();

    // Reiniciar ruleta con un Brawler visible
    const maxForDaily = (activePrepared && activeBrawlers.length>0) ? activeBrawlers.length : allBrawlers.length;
    const dailyIdx = getDailyIndex(maxForDaily); // Para mantener un brawler aleatorio del d√≠a
    const dailyName = (activePrepared && activeBrawlers.length>0) ? activeBrawlers[dailyIdx] : allBrawlers[dailyIdx];
    safeSetBrawler(dailyName);
    brawlerImg.className = "finalGlow"; // Glow sutil para que no se vea apagado

    // Scroll hacia arriba al formulario
    document.getElementById('calcForm').scrollIntoView({behavior:'smooth', block:'start'}); 
  }

  /* ===== COMPARTIR ===== */
  async function share(){
    beep(500); vibrar(); shareBtn.classList.add('flash'); setTimeout(()=>shareBtn.classList.remove('flash'),200);
    const url = window.location.href;
    const text = "Mira cu√°nto valen mis Brawlers en Brawl Stars!";
    if(navigator.share){
      try{await navigator.share({title:"Calculadora Brawl Stars",text,url});}
      catch(err){console.log(err);}
    } else {
      try{
        await navigator.clipboard.writeText(url);
        alert("Enlace copiado al portapapeles ‚úÖ");
      }catch(e){
        // fallback m√°s primitivo
        prompt("Copia este enlace:", url);
      }
    }
  }

  /* ===== VOTO √öNICO POR USUARIO (like/dislike) ===== */
  function getUserVote() {
    return JSON.parse(localStorage.getItem(`${PAGE_ID}-vote`) || '{}');
  }

  function setUserVote(vote) {
    localStorage.setItem(`${PAGE_ID}-vote`, JSON.stringify(vote));
  }

  likesCounter.addEventListener('click', async () => {
    beep(400); vibrar();
    let vote = getUserVote();
    if(vote.type === 'like'){
      vote = {};
      await supabase.rpc('decrement_likes',{pid: PAGE_ID});
    } else {
      if(vote.type === 'dislike'){
        await supabase.rpc('decrement_dislikes',{pid: PAGE_ID});
      }
      vote = { type: 'like' };
      await supabase.rpc('increment_likes',{pid: PAGE_ID});
    }
    setUserVote(vote);
    cargarMetricas();
  });

  dislikesCounter.addEventListener('click', async () => {
    beep(300); vibrar();
    let vote = getUserVote();
    if(vote.type === 'dislike'){
      vote = {};
      await supabase.rpc('decrement_dislikes',{pid: PAGE_ID});
    } else {
      if(vote.type === 'like'){
        await supabase.rpc('decrement_likes',{pid: PAGE_ID});
      }
      vote = { type: 'dislike' };
      await supabase.rpc('increment_dislikes',{pid: PAGE_ID});
    }
    setUserVote(vote);
    cargarMetricas();
  });

/* ===== DAILY BRAWLER Y RULETA SIN QUE EMPIECE CON √âL ===== */
function getDailyBrawler() {
  const maxForDaily = (activePrepared && activeBrawlers.length > 0) ? activeBrawlers.length : allBrawlers.length;
  const dailyIdx = getDailyIndex(maxForDaily);
  return (activePrepared && activeBrawlers.length > 0) ? activeBrawlers[dailyIdx] : allBrawlers[dailyIdx];
}

function prepareRouletteList() {
  const dailyName = getDailyBrawler(); 
  let rouletteBrawlers = activeBrawlers.slice(); // clonamos la lista

  // Si el primer brawler es el daily, intercambiamos con otro aleatorio
  if (rouletteBrawlers[0] === dailyName && rouletteBrawlers.length > 1) {
    const swapIdx = Math.floor(Math.random() * (rouletteBrawlers.length - 1)) + 1;
    [rouletteBrawlers[0], rouletteBrawlers[swapIdx]] = [rouletteBrawlers[swapIdx], rouletteBrawlers[0]];
  }

  return rouletteBrawlers;
    }

  /* ===== RULETA (usa activeBrawlers si est√°n listos) ===== */
  function spinRouletteSmooth() {
    const brawlersList = prepareRouletteList();
    const numBrawlers = brawlersList.length;
    const finalIndex = getDailyIndex(numBrawlers);
    const totalDuration = 10000;
    const slowDuration = 2000;
    const fastDuration = totalDuration - slowDuration;
    const finalSlowSteps = Math.min(6, numBrawlers);

    // Secuencias de √≠ndices
    const indices = Array.from({ length: numBrawlers }, (_, i) => i);
    const shuffledFast = [...indices].sort(() => Math.random() - 0.5);
    const temp = indices.filter(i => i !== finalIndex);
    const slowSequence = [];
    for (let i = 0; i < finalSlowSteps - 1; i++) {
      const idx = Math.floor(Math.random() * temp.length);
      slowSequence.push(temp[idx]);
      temp.splice(idx, 1);
    }
    slowSequence.push(finalIndex);

    const glowClasses = ["glow-blue", "glow-red", "glow-orange", "glow-green"];
    const startTime = performance.now();

    // showImageSafe (sin bloquear, pero garantizando fallback si falla)
    function showImageSafe(name, glowClass) {
      const img = brawlerCache[name];
      const loadedActive = getLoadedImagesFromList(brawlersList);
      const loadedAny = Object.values(brawlerCache).filter(i => i && i.complete && i.naturalWidth>0);

      if(img && img.complete && img.naturalWidth>0){
        brawlerImg.src = img.src;
      } else if(loadedActive.length > 0){
        const randomImg = loadedActive[Math.floor(Math.random()*loadedActive.length)];
        brawlerImg.src = randomImg.src;
      } else if(loadedAny.length > 0){
        const randomImg = loadedAny[Math.floor(Math.random()*loadedAny.length)];
        brawlerImg.src = randomImg.src;
      } else {
        brawlerImg.src = "https://via.placeholder.com/210x210?text=Brawler";
      }
      brawlerImg.className = glowClass;
      // no devolvemos promesas: la animaci√≥n no espera la carga completa para mantener fluidez
    }

    // Animaci√≥n con requestAnimationFrame (fase r√°pida + lenta)
    let fastStep = 0;
    let slowStep = 0;
    let phase = "fast";
    let lastTime = performance.now();
    const fastInterval = 60; // ms por frame r√°pido

    function animate(currentTime){
      const elapsed = currentTime - startTime;

      if(phase === "fast"){
        if(elapsed >= fastDuration){
          phase = "slow";
          lastTime = currentTime;
        } else if(currentTime - lastTime >= fastInterval){
          const name = brawlersList[shuffledFast[fastStep % shuffledFast.length]];
          const glow = glowClasses[fastStep % glowClasses.length];
          showImageSafe(name, glow);
          fastStep++; lastTime = currentTime;
        }
      }

      if(phase === "slow"){
        const slowElapsed = elapsed - fastDuration;
        const stepDuration = slowDuration / finalSlowSteps;
        if(slowElapsed >= stepDuration * slowStep){
          if(slowStep < finalSlowSteps){
            const idx = slowSequence[slowStep];
            const name = brawlersList[idx];
            const glow = slowStep < finalSlowSteps - 1 ? glowClasses[(fastStep + slowStep) % glowClasses.length] : "glow-green finalGlow";
            showImageSafe(name, glow);
            slowStep++;
          }
          if(slowStep >= finalSlowSteps){
            const finalName = brawlersList[finalIndex];
            safeSetBrawler(finalName, "glow-green finalGlow");
            confetti({ particleCount: 150, spread: 90, origin: { y: 0.5 } });
            return; // animaci√≥n completa
          }
        }
      }

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  /* ===== INICIALIZACI√ìN ===== */
// deshabilitamos spin hasta que prepareActiveBrawlers termine
if(spinBtn) spinBtn.disabled = true;

prepareActiveBrawlers(20).then(selected => {
  // Determinamos el brawler del d√≠a
  const maxForDaily = (activePrepared && activeBrawlers.length>0) ? activeBrawlers.length : allBrawlers.length;
  const dailyIdx = getDailyIndex(maxForDaily);
  const dailyName = (activePrepared && activeBrawlers.length>0) ? activeBrawlers[dailyIdx] : allBrawlers[dailyIdx];

  // 1Ô∏è‚É£ Mostramos el brawler del d√≠a al cargar
  safeSetBrawler(dailyName);

  // 2Ô∏è‚É£ Elegimos un brawler inicial para la ruleta que NO sea el del d√≠a
  if(activePrepared && activeBrawlers.length > 1){
    const otherBrawlers = activeBrawlers.filter((b, i) => i !== dailyIdx);
    const startIdx = Math.floor(Math.random() * otherBrawlers.length);
    const startBrawler = otherBrawlers[startIdx];
    // guardamos este brawler para la ruleta (puedes usarlo en spinRouletteSmooth)
    brawlerImg.dataset.startBrawler = startBrawler;
  } else {
    // fallback: si solo hay 1 brawler, lo usamos igual
    brawlerImg.dataset.startBrawler = dailyName;
  }

  // habilitamos el bot√≥n de spin
  if(spinBtn) spinBtn.disabled = false;

}).catch(e => {
  console.warn("prepareActiveBrawlers fallo: ", e);
  // fallback: intenta mostrar un brawler del conjunto completo
  const idx = getDailyIndex(allBrawlers.length);
  const name = allBrawlers[idx];
  safeSetBrawler(name);
  if(spinBtn) spinBtn.disabled = false;
});

// Cargamos m√©tricas e incrementamos visita (puede ejecutarse en paralelo)
cargarMetricas();
incrementarVisita();
});
</script>
</body>
</html>
